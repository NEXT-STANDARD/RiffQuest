<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RiffQuest BPM 検出テスト v3 (AG03対応)</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      max-width: 900px;
      margin: 50px auto;
      padding: 30px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #fff;
    }

    h1 {
      text-align: center;
      font-size: 2.5em;
      margin-bottom: 10px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }

    .subtitle {
      text-align: center;
      opacity: 0.9;
      margin-bottom: 40px;
    }

    .container {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      padding: 40px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }

    .bpm-display {
      text-align: center;
      font-size: 6em;
      font-weight: bold;
      margin: 40px 0;
      text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.3);
      transition: all 0.3s ease;
    }

    .bpm-label {
      text-align: center;
      font-size: 1.2em;
      opacity: 0.8;
      margin-bottom: 20px;
    }

    .status {
      text-align: center;
      padding: 15px;
      border-radius: 10px;
      margin: 20px 0;
      font-weight: bold;
      transition: all 0.3s ease;
    }

    .status.idle {
      background: rgba(255, 255, 255, 0.2);
    }

    .status.listening {
      background: rgba(81, 207, 102, 0.3);
      animation: pulse 2s infinite;
    }

    .status.error {
      background: rgba(255, 107, 107, 0.3);
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }

    .controls {
      display: flex;
      gap: 15px;
      justify-content: center;
      margin: 30px 0;
      flex-wrap: wrap;
    }

    button {
      padding: 15px 40px;
      font-size: 1.1em;
      font-weight: bold;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
    }

    button:active {
      transform: translateY(0);
    }

    .btn-start {
      background: linear-gradient(135deg, #51cf66 0%, #37b24d 100%);
      color: white;
    }

    .btn-stop {
      background: linear-gradient(135deg, #ff6b6b 0%, #fa5252 100%);
      color: white;
    }

    .btn-stop:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .threshold-control {
      background: rgba(255, 255, 255, 0.1);
      padding: 20px;
      border-radius: 10px;
      margin: 20px 0;
    }

    .threshold-control label {
      display: block;
      margin-bottom: 10px;
    }

    .threshold-control input[type="range"] {
      width: 100%;
      height: 8px;
      border-radius: 5px;
      background: rgba(255, 255, 255, 0.3);
      outline: none;
    }

    .threshold-value {
      text-align: center;
      font-size: 1.5em;
      font-weight: bold;
      margin-top: 10px;
    }

    .waveform {
      width: 100%;
      height: 150px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 10px;
      margin: 20px 0;
    }

    .debug {
      background: rgba(0, 0, 0, 0.5);
      padding: 20px;
      border-radius: 10px;
      margin-top: 20px;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
      max-height: 300px;
      overflow-y: auto;
    }

    .debug-line {
      margin: 5px 0;
      color: #51cf66;
    }

    .debug-line.warning {
      color: #ffd700;
    }

    .debug-line.error {
      color: #ff6b6b;
    }

    .accuracy {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 15px;
      margin-top: 20px;
    }

    .accuracy-item {
      background: rgba(255, 255, 255, 0.1);
      padding: 15px;
      border-radius: 10px;
      text-align: center;
    }

    .accuracy-label {
      opacity: 0.8;
      font-size: 0.9em;
    }

    .accuracy-value {
      font-size: 1.5em;
      font-weight: bold;
      margin-top: 5px;
    }

    .info {
      background: rgba(255, 255, 255, 0.1);
      padding: 20px;
      border-radius: 10px;
      margin-top: 30px;
    }

    .info h3 {
      margin-top: 0;
    }

    .info ul {
      margin: 10px 0;
      padding-left: 20px;
    }

    .info li {
      margin: 8px 0;
    }

    .peak-indicator {
      width: 100%;
      height: 40px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 10px;
      margin: 10px 0;
      position: relative;
      overflow: hidden;
    }

    .peak-bar {
      height: 100%;
      background: linear-gradient(90deg, #51cf66 0%, #ffd700 50%, #ff6b6b 100%);
      width: 0%;
      transition: width 0.1s;
    }

    .threshold-line {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 2px;
      background: #fff;
      box-shadow: 0 0 10px #fff;
    }
  </style>
</head>
<body>
  <h1>🎸 RiffQuest BPM 検出テスト v3</h1>
  <p class="subtitle">AG03 オーディオインターフェース対応版</p>

  <div class="container">
    <div class="bpm-label">推定 BPM</div>
    <div class="bpm-display" id="bpm-display">---</div>

    <div class="status idle" id="status">
      準備完了 - メトロノームを起動してください
    </div>

    <div class="threshold-control">
      <label for="threshold-slider">検出感度 (閾値調整)</label>
      <input type="range" id="threshold-slider" min="0.001" max="0.5" step="0.001" value="0.05">
      <div class="threshold-value">閾値: <span id="threshold-value">0.050</span></div>
      <p style="font-size: 0.9em; opacity: 0.8; margin-top: 10px;">
        💡 ビートが検出されない場合は、スライダーを左に動かして感度を上げてください
      </p>
    </div>

    <div class="peak-indicator">
      <div class="peak-bar" id="peak-bar"></div>
      <div class="threshold-line" id="threshold-line"></div>
    </div>

    <canvas id="waveform" class="waveform"></canvas>

    <div class="controls">
      <button class="btn-start" id="start-btn">🎵 BPM 検出開始</button>
      <button class="btn-stop" id="stop-btn" disabled>⏹️ 停止</button>
    </div>

    <div class="accuracy">
      <div class="accuracy-item">
        <div class="accuracy-label">経過時間</div>
        <div class="accuracy-value" id="sample-time">0.0s</div>
      </div>
      <div class="accuracy-item">
        <div class="accuracy-label">検出数</div>
        <div class="accuracy-value" id="detect-count">0</div>
      </div>
      <div class="accuracy-item">
        <div class="accuracy-label">現在RMS</div>
        <div class="accuracy-value" id="current-rms">0.000</div>
      </div>
    </div>

    <div class="debug" id="debug">
      <div class="debug-line">デバッグログがここに表示されます...</div>
    </div>

    <div class="info">
      <h3>📝 使用方法（AG03 向け）</h3>
      <ul>
        <li>メトロノームアプリを起動（120 BPM 推奨）</li>
        <li>AG03 の入力レベルを調整（LEDメーターが振れる程度）</li>
        <li>マイク選択で AG03 を選択</li>
        <li>"BPM 検出開始" をクリック</li>
        <li>ピークインジケーター（緑のバー）が動いているか確認</li>
        <li>ビートが検出されない場合は「検出感度」を調整</li>
      </ul>

      <h3>🎯 デバッグ情報の見方</h3>
      <ul>
        <li><strong>現在RMS:</strong> 音の強さ（0.05 以上が理想）</li>
        <li><strong>ピークバー:</strong> リアルタイムの音量（緑バーが閾値を超えるとビート検出）</li>
        <li><strong>検出数:</strong> ビートを検出した回数（増えていれば正常）</li>
      </ul>
    </div>
  </div>

  <script>
    let audioContext = null;
    let analyser = null;
    let microphone = null;
    let animationId = null;
    let isDetecting = false;
    let beatTimestamps = [];
    let bpmHistory = [];
    let startTime = null;
    let detectionCount = 0;
    let threshold = 0.05;

    const startBtn = document.getElementById('start-btn');
    const stopBtn = document.getElementById('stop-btn');
    const bpmDisplay = document.getElementById('bpm-display');
    const statusEl = document.getElementById('status');
    const sampleTimeEl = document.getElementById('sample-time');
    const detectCountEl = document.getElementById('detect-count');
    const currentRmsEl = document.getElementById('current-rms');
    const debugEl = document.getElementById('debug');
    const canvas = document.getElementById('waveform');
    const canvasCtx = canvas.getContext('2d');
    const thresholdSlider = document.getElementById('threshold-slider');
    const thresholdValueEl = document.getElementById('threshold-value');
    const peakBar = document.getElementById('peak-bar');
    const thresholdLine = document.getElementById('threshold-line');

    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;

    // 閾値スライダーのイベント
    thresholdSlider.addEventListener('input', (e) => {
      threshold = parseFloat(e.target.value);
      thresholdValueEl.textContent = threshold.toFixed(3);
      updateThresholdLine();
      if (isDetecting) {
        addDebug(`閾値を ${threshold.toFixed(3)} に変更`, 'warning');
      }
    });

    function updateThresholdLine() {
      const percent = (threshold / 0.5) * 100;
      thresholdLine.style.left = percent + '%';
    }

    updateThresholdLine();

    startBtn.addEventListener('click', startDetection);
    stopBtn.addEventListener('click', stopDetection);

    function addDebug(message, type = 'normal') {
      const line = document.createElement('div');
      line.className = 'debug-line';
      if (type === 'warning') line.classList.add('warning');
      if (type === 'error') line.classList.add('error');

      const time = new Date().toLocaleTimeString('ja-JP');
      line.textContent = `[${time}] ${message}`;
      debugEl.insertBefore(line, debugEl.firstChild);

      while (debugEl.children.length > 50) {
        debugEl.removeChild(debugEl.lastChild);
      }
    }

    async function startDetection() {
      try {
        statusEl.textContent = 'マイクへのアクセスを要求中...';
        statusEl.className = 'status idle';
        addDebug('マイクへのアクセスを要求中...');

        const stream = await navigator.mediaDevices.getUserMedia({
          audio: {
            echoCancellation: false,
            noiseSuppression: false,
            autoGainControl: false,
            sampleRate: 44100
          }
        });

        addDebug('✅ マイクアクセス許可 (AG03)');

        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 4096; // より精密な解析
        analyser.smoothingTimeConstant = 0.3;

        microphone = audioContext.createMediaStreamSource(stream);
        microphone.connect(analyser);

        addDebug(`AudioContext 作成: サンプルレート ${audioContext.sampleRate}Hz`);
        addDebug(`FFT サイズ: ${analyser.fftSize}`);
        addDebug(`初期閾値: ${threshold.toFixed(3)}`);

        isDetecting = true;
        beatTimestamps = [];
        bpmHistory = [];
        startTime = Date.now();
        detectionCount = 0;

        startBtn.disabled = true;
        stopBtn.disabled = false;

        statusEl.textContent = '🎧 BPM を検出中... (感度を調整してください)';
        statusEl.className = 'status listening';
        addDebug('検出開始 - メトロノームを鳴らしてください');

        detect();

      } catch (error) {
        statusEl.textContent = 'エラー: ' + error.message;
        statusEl.className = 'status error';
        addDebug('❌ エラー: ' + error.message, 'error');
        console.error('Error:', error);
      }
    }

    function stopDetection() {
      isDetecting = false;

      if (microphone) {
        microphone.disconnect();
        microphone = null;
      }

      if (audioContext) {
        audioContext.close();
        audioContext = null;
      }

      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }

      startBtn.disabled = false;
      stopBtn.disabled = true;

      statusEl.textContent = '停止しました';
      statusEl.className = 'status idle';
      addDebug('検出停止');
    }

    let lastBeatTime = 0;
    const MIN_BEAT_INTERVAL = 250; // 最小ビート間隔（ms）= 240 BPM

    function detect() {
      if (!isDetecting) return;

      const bufferLength = analyser.frequencyBinCount;
      const dataArray = new Uint8Array(bufferLength);
      analyser.getByteTimeDomainData(dataArray);

      // 波形描画
      drawWaveform(dataArray, bufferLength);

      // RMS計算
      let sum = 0;
      for (let i = 0; i < bufferLength; i++) {
        const normalized = (dataArray[i] - 128) / 128.0;
        sum += normalized * normalized;
      }
      const rms = Math.sqrt(sum / bufferLength);
      currentRmsEl.textContent = rms.toFixed(3);

      // ピークバー更新
      const peakPercent = Math.min(100, (rms / 0.5) * 100);
      peakBar.style.width = peakPercent + '%';

      // ビート検出
      const now = Date.now();

      if (rms > threshold && (now - lastBeatTime) > MIN_BEAT_INTERVAL) {
        beatTimestamps.push(now);
        lastBeatTime = now;
        detectionCount++;
        detectCountEl.textContent = detectionCount;
        addDebug(`🎵 ビート検出! RMS: ${rms.toFixed(3)} > 閾値: ${threshold.toFixed(3)}`);

        // BPM計算（最後の3〜10ビートを使用）
        if (beatTimestamps.length >= 3) {
          const recentBeats = beatTimestamps.slice(-10);
          const intervals = [];

          for (let i = 1; i < recentBeats.length; i++) {
            intervals.push(recentBeats[i] - recentBeats[i - 1]);
          }

          const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
          const bpm = Math.round(60000 / avgInterval);

          if (bpm >= 40 && bpm <= 240) {
            bpmHistory.push(bpm);
            addDebug(`計算: 平均間隔 ${Math.round(avgInterval)}ms → ${bpm} BPM`);

            // 最新10サンプルの中央値を使用（外れ値に強い）
            const recentBPMs = bpmHistory.slice(-10);
            const sortedBPMs = [...recentBPMs].sort((a, b) => a - b);
            const medianBPM = sortedBPMs[Math.floor(sortedBPMs.length / 2)];

            bpmDisplay.textContent = medianBPM;
            addDebug(`✅ 中央値 BPM: ${medianBPM} (サンプル数: ${recentBPMs.length})`);
          } else {
            addDebug(`⚠️ BPM が範囲外: ${bpm} (40-240 BPM の範囲内である必要があります)`, 'warning');
          }
        }

        // 古いビートタイムスタンプを削除（15秒以上前）
        beatTimestamps = beatTimestamps.filter(ts => (now - ts) < 15000);
      }

      // 経過時間を更新
      const elapsedTime = (Date.now() - startTime) / 1000;
      sampleTimeEl.textContent = elapsedTime.toFixed(1) + 's';

      animationId = requestAnimationFrame(detect);
    }

    function drawWaveform(dataArray, bufferLength) {
      canvasCtx.fillStyle = 'rgba(0, 0, 0, 0.2)';
      canvasCtx.fillRect(0, 0, canvas.width, canvas.height);

      canvasCtx.lineWidth = 2;
      canvasCtx.strokeStyle = '#51cf66';
      canvasCtx.beginPath();

      const sliceWidth = canvas.width / bufferLength;
      let x = 0;

      for (let i = 0; i < bufferLength; i++) {
        const v = dataArray[i] / 128.0;
        const y = (v * canvas.height) / 2;

        if (i === 0) {
          canvasCtx.moveTo(x, y);
        } else {
          canvasCtx.lineTo(x, y);
        }

        x += sliceWidth;
      }

      canvasCtx.lineTo(canvas.width, canvas.height / 2);
      canvasCtx.stroke();
    }
  </script>
</body>
</html>
